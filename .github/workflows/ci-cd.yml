name: Build, Test & Push Docker Image

on:
  push:
    branches:
      - jazzy-devel
  pull_request:
    branches:
      - jazzy-devel
  workflow_dispatch:

jobs:
  build:
    runs-on: ubuntu-latest
    timeout-minutes: 45
    
    env:
      # Package Configuration - Define your ROS2 Python packages here
      PY_PACKAGES: "face_detection face_recognition gaze_estimation visual_speech_activity"
    
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
      
      # Clone EutRobAIDockers repository to build base image
      - name: Clone EutRobAIDockers repository
        run: |
          git clone https://github.com/Eurecat/EutRobAIDockers.git
          cd EutRobAIDockers
          echo "‚úÖ EutRobAIDockers repository cloned successfully"
      
      # Build the base image (eut_ros_torch_cpu:jazzy)
      - name: Build base image from EutRobAIDockers
        run: |
          cd EutRobAIDockers/Docker
          chmod +x build_container.sh
          ./build_container.sh --cpu --vulcanexus
        env:
          DOCKER_BUILDKIT: 1
      
      # Verify base image was built successfully
      - name: Verify base image was built
        run: |
          if docker images | grep -q "eut_ros_vulcanexus_torch_cpu.*jazzy"; then
            echo "‚úÖ Base image eut_ros_vulcanexus_torch_cpu:jazzy successfully built"
            docker images eut_ros_vulcanexus_torch_cpu:jazzy
          else
            echo "‚ùå Base image eut_ros_vulcanexus_torch_cpu:jazzy not found"
            echo "Available images:"
            docker images
            exit 1
          fi
      
      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3
      
      - name: Install vcstool for dependency management
        run: |
          sudo apt-get update
          sudo apt-get install -y python3-pip
          pip3 install --break-system-packages vcstool
      
      - name: Make build script executable
        run: chmod +x Docker/build_container.sh
      
      # Build the EutHRIFaces Docker image (depends on base image)
      - name: Build EutHRIFaces Docker image
        run: cd ./Docker && ./build_container.sh --cpu --vulcanexus
        env:
          DOCKER_BUILDKIT: 1
      
      - name: Verify EutHRIFaces image was built
        run: |
          if docker images | grep -q "eut_human_face_vulcanexus_cpu.*jazzy"; then
            echo "‚úÖ EutHRIFaces image eut_human_face_vulcanexus_cpu:jazzy successfully built"
            docker images eut_human_face_vulcanexus_cpu:jazzy
          else
            echo "‚ùå EutHRIFaces image eut_human_face_vulcanexus_cpu:jazzy not found"
            echo "Available images:"
            docker images
            exit 1
          fi
        
      # üîß Build workspace and run test
      - name: Build & test workspace
        run: |
          source Docker/.env
          
          # Build all packages with proper dependency order
          docker run --rm \
            -v ${{ github.workspace }}:/workspace \
            ${BUILT_IMAGE} \
            bash -c "
              # Source ROS environment (jazzy is available in both vulcanexus and standard images)
              if [ -f /opt/vulcanexus/jazzy/setup.bash ]; then
                source /opt/vulcanexus/jazzy/setup.bash
              elif [ -f /opt/ros/jazzy/setup.bash ]; then
                source /opt/ros/jazzy/setup.bash
              fi
              
              cd /workspace
              
              # Source the pre-built workspace dependencies from image (hri_msgs, etc.)
              if [ -f /opt/workspace/install/setup.bash ]; then
                source /opt/workspace/install/setup.bash
                echo '‚úÖ Sourced pre-built dependencies from image'
              fi
              
              echo 'üîç Available packages to build:'
              colcon list --names-only
              
              # Build Python packages
              echo 'üî® Building Python packages: ${{ env.PY_PACKAGES }}'
              
              colcon build --symlink-install \
                --packages-select ${{ env.PY_PACKAGES }} \
                --parallel-workers 1 \
                --event-handlers console_direct+ || echo 'Warning: Some Python packages failed to build'
              
              # Source the workspace to make built packages available
              source install/setup.bash
              
              # Set up test environment
              export PYTHONDONTWRITEBYTECODE=1
              export PYTHONHASHSEED=0
              export AI_VENV='/opt/ros_python_env'
              
              # Ensure pytest-cov is installed
              pip3 install pytest-cov --break-system-packages --quiet || pip3 install pytest-cov --user --quiet
              
              # Run tests for Python packages (one at a time to reduce memory)
              echo 'üß™ Running tests...'
              PY_PACKAGES_LIST='${{ env.PY_PACKAGES }}'
              
              # List workspace structure to debug
              echo \"üìÅ Workspace structure:\"
              ls -la /workspace/ | head -20
              
              for pkg in \${PY_PACKAGES_LIST}; do
                echo \"\n========================================\"
                echo \"Testing package: \$pkg\"
                echo \"========================================\"
                
                # Create build directory for coverage output
                mkdir -p /workspace/build/\$pkg/htmlcov
                
                # Check where the package actually is
                if [ -d \"/workspace/\$pkg\" ]; then
                  PKG_PATH=\"/workspace/\$pkg\"
                elif [ -d \"/workspace/src/\$pkg\" ]; then
                  PKG_PATH=\"/workspace/src/\$pkg\"
                else
                  echo \"‚ö†Ô∏è Package \$pkg not found in /workspace or /workspace/src\"
                  continue
                fi
                
                echo \"‚ÑπÔ∏è Testing from: \$PKG_PATH\"
                cd \"\$PKG_PATH\"
                
                # Run tests with pytest and ensure coverage is generated
                python3 -m pytest test/ \
                  -v \
                  --tb=short \
                  --junitxml=/workspace/build/\$pkg/pytest.xml \
                  --cov=\$pkg \
                  --cov-report=html:/workspace/build/\$pkg/htmlcov \
                  --cov-report=lcov:/workspace/build/\$pkg/coverage.lcov \
                  --cov-report=xml:/workspace/build/\$pkg/coverage.xml \
                  --cov-report=term \
                  -p no:cacheprovider || TEST_FAILED=1
                
                # Verify coverage files were created
                echo \"\"
                echo \"Checking coverage files for \$pkg:\"
                ls -lh /workspace/build/\$pkg/coverage.* 2>/dev/null || echo \"‚ö†Ô∏è No coverage files found\"
                
                cd /workspace
                # Brief pause between packages
                sleep 1
              done
              
              if [ \"\$TEST_FAILED\" = \"1\" ]; then
                echo \"‚ö†Ô∏è Some tests failed, but continuing with coverage report\"
              fi
            "

      # Generate human-readable test summary
      - name: Generate test summary
        if: always()
        run: |
          source Docker/.env
          docker run --rm \
            -v ${{ github.workspace }}:/workspace \
            ${BUILT_IMAGE} \
            bash -c "
              cd /workspace
              if [ -f /opt/vulcanexus/jazzy/setup.bash ]; then
                source /opt/vulcanexus/jazzy/setup.bash
              elif [ -f /opt/ros/jazzy/setup.bash ]; then
                source /opt/ros/jazzy/setup.bash
              fi
              source install/setup.bash 2>/dev/null || true
              colcon test-result --all --verbose
            " > test_summary.txt
          
          # Display in logs
          cat test_summary.txt
          
          # Create GitHub Actions summary
          echo "## üß™ Test Results Summary" >> $GITHUB_STEP_SUMMARY
          echo '```' >> $GITHUB_STEP_SUMMARY
          cat test_summary.txt >> $GITHUB_STEP_SUMMARY
          echo '```' >> $GITHUB_STEP_SUMMARY

      # Debug: Check build directory structure
      - name: Debug build directory structure
        if: always()
        run: |
          echo "üìã Build directory contents:"
          find build -type f | head -50
          echo ""
          echo "üìã Build directory tree:"
          find build -maxdepth 3 -type d
      
      - name: Generate test Report
        uses: dorny/test-reporter@v1
        if: always()
        with:
          name: ROS 2 Tests
          path: 'build/*/test_results/**/*.xml,build/*/pytest.xml'
          reporter: java-junit
          fail-on-error: false
      
      # Upload test result
      - name: Upload test results
        if: always()
        continue-on-error: true
        uses: actions/upload-artifact@v4
        with:
          name: test-results
          path: |
            build/*/test_results/**/*.xml
            build/*/pytest.xml
            log/latest_test/**/*.log
            test_summary.txt
          if-no-files-found: warn      
      # Verify coverage files were generated
      - name: Verify coverage files
        if: always()
        run: |
          echo "üìã Coverage files generated:"
          echo ""
          find build -type f \( -name "coverage.*" -o -name ".coverage" \) 2>/dev/null | while read f; do
            echo "‚úÖ $f ($(du -h "$f" | cut -f1))"
          done
          echo ""
          echo "üìã Test result files:"
          find build -name "pytest.xml" -type f 2>/dev/null | while read f; do
            echo "‚úÖ $f"
          done
          echo ""
          echo "üìã HTML coverage files:"
          find build -type d -name "htmlcov" 2>/dev/null | while read d; do
            echo "‚úÖ $d/ ($(find "$d" -type f | wc -l) files)"
          done
      # Create test badge (for README)
      - name: Create test badge
        if: always() && github.ref == 'refs/heads/jazzy-devel'
        run: |
          # Parse the summary line from test_summary.txt
          # Example line: "Summary: 55 tests, 0 errors, 0 failures, 6 skipped"
          if [ -f test_summary.txt ]; then
            SUMMARY_LINE=$(grep "^Summary:" test_summary.txt)
            
            # Extract numbers using grep and cut
            TOTAL=$(echo "$SUMMARY_LINE" | grep -oP '\d+(?= tests)' || echo "0")
            FAILURES=$(echo "$SUMMARY_LINE" | grep -oP '\d+(?= failures)' || echo "0")
            ERRORS=$(echo "$SUMMARY_LINE" | grep -oP '\d+(?= errors)' || echo "0")
            
            # Calculate passed tests (total - failures - errors)
            PASSED=$((TOTAL - FAILURES - ERRORS))
            FAILED=$((FAILURES + ERRORS))
            
            echo "üìä Badge stats: $PASSED passed / $FAILED failed (out of $TOTAL total)"
          else
            echo "‚ö†Ô∏è test_summary.txt not found, using defaults"
            PASSED=0
            FAILED=0
          fi
          
          # Create badge JSON (shields.io endpoint format)
          COLOR="success"
          if [ $FAILED -gt 0 ]; then
            COLOR="critical"
          fi
          
          echo "{\"schemaVersion\": 1, \"label\": \"tests\", \"message\": \"$PASSED passed / $FAILED failed\", \"color\": \"$COLOR\"}" > test-badge.json
          
          cat test-badge.json

      - name: Upload badge data
        if: always() && github.ref == 'refs/heads/jazzy-devel'
        continue-on-error: true
        uses: actions/upload-artifact@v4
        with:
          name: test-badge
          path: test-badge.json
          if-no-files-found: warn
      

      # Generate code coverage reports (from existing test data)
      - name: Generate coverage reports
        if: always()
        run: |
          source Docker/.env
          
          echo '=========================================='
          echo '  Code Coverage Summary Display'
          echo '=========================================='
          echo ''
          
          # Display Python coverage from existing files
          for pkg in ${{ env.PY_PACKAGES }}; do
            echo "üìä Python Coverage (${pkg})"
            echo '------------------------------------------'
            
            # Check for lcov file
            if [ -f "build/${pkg}/coverage.lcov" ]; then
              echo "‚úÖ Coverage data found in build/${pkg}/coverage.lcov"
              # Extract summary from lcov
              grep "^LH:\|^LF:" "build/${pkg}/coverage.lcov" | head -5 || true
            elif [ -f "build/${pkg}/coverage.xml" ]; then
              echo "‚úÖ Coverage data found in build/${pkg}/coverage.xml"
            else
              echo "‚ö†Ô∏è  No coverage data found for this package"
            fi
            echo ''
          done
          
          echo '=========================================='
          echo '‚úÖ Coverage Reports Generated!'
          echo '=========================================='
          
          # Summary of files found
          echo ""
          echo "Coverage files summary:"
          find build -name "coverage.*" -type f 2>/dev/null | wc -l
          echo "coverage files found"
      
      # Convert lcov to Cobertura XML for better tool compatibility
      - name: Convert coverage to Cobertura XML
        if: always()
        continue-on-error: true
        run: |
          python3 -m pip install lcov_cobertura --quiet
          
          echo "üìã Looking for coverage files..."
          echo ""
          
          # Track if any files were found
          FILES_FOUND=0
          
          # Convert Python coverage lcov files to XML
          for pkg in ${{ env.PY_PACKAGES }}; do
            LCOV_FILE="build/${pkg}/coverage.lcov"
            if [ -f "$LCOV_FILE" ]; then
              echo "‚úÖ Converting Python coverage for ${pkg}..."
              if python3 -m lcov_cobertura "$LCOV_FILE" -o "coverage-py-${pkg}.xml"; then
                echo "‚úÖ Generated: coverage-py-${pkg}.xml"
                FILES_FOUND=$((FILES_FOUND + 1))
              else
                echo "‚ö†Ô∏è Failed to convert LCOV for ${pkg}"
              fi
            else
              echo "‚ÑπÔ∏è coverage.lcov not found for ${pkg} at $LCOV_FILE"
            fi
          done
          
          # Also copy any existing coverage.xml files
          for pkg in ${{ env.PY_PACKAGES }}; do
            if [ -f "build/${pkg}/coverage.xml" ]; then
              cp "build/${pkg}/coverage.xml" "coverage-py-${pkg}-direct.xml"
              echo "‚úÖ Copied coverage.xml for ${pkg}"
              FILES_FOUND=$((FILES_FOUND + 1))
            fi
          done
          
          # List all generated coverage files
          echo ""
          echo "üìã Coverage conversion summary:"
          ls -lh coverage-*.xml 2>/dev/null && echo "‚úÖ Coverage XML files generated" || echo "‚ÑπÔ∏è No coverage XML files generated (tests may have been skipped or failed)"
          echo ""
          echo "üìã All build coverage files:"
          find build -name "coverage.*" -type f 2>/dev/null | head -20
      
      # Generate Coverage Report for PR (using Cobertura XML)
      - name: Code Coverage Report
        uses: irongut/CodeCoverageSummary@v1.3.0
        if: always()
        continue-on-error: true
        with:
          filename: 'coverage-*.xml'
          badge: true
          fail_below_min: false
          format: markdown
          hide_branch_rate: false
          hide_complexity: true
          indicators: true
          output: both
          thresholds: '60 80'
      
      # Add coverage report to PR comment
      - name: Add Coverage PR Comment
        uses: marocchino/sticky-pull-request-comment@v2
        if: github.event_name == 'pull_request'
        continue-on-error: true
        with:
          recreate: true
          path: code-coverage-results.md
      
      # Upload coverage reports as artifacts
      - name: Upload coverage reports
        if: always()
        continue-on-error: true
        uses: actions/upload-artifact@v4
        with:
          name: coverage-reports
          path: |
            build/*/htmlcov
            build/*/coverage.lcov
            build/*/coverage.xml
            coverage_summary.txt
            coverage-*.xml
          if-no-files-found: warn
      
      # Create coverage badge (for README)
      - name: Create coverage badge
        if: always() && github.ref == 'refs/heads/jazzy-devel'
        continue-on-error: true
        run: |
          # Extract Python coverage percentage from lcov file
          echo "üîç Searching for Python coverage files..."
          find . -name "coverage.lcov" -o -name ".coverage" 2>/dev/null | head -20
          
          # Extract Python coverage for all packages
          PY_TOTAL_LINES_HIT=0
          PY_TOTAL_LINES_FOUND=0
          
          for pkg in ${{ env.PY_PACKAGES }}; do
            echo "üîç Checking Python coverage for: ${pkg}"
            PY_LCOV_FILE=""
            
            if [ -f "build/${pkg}/coverage.lcov" ]; then
              PY_LCOV_FILE="build/${pkg}/coverage.lcov"
              echo "‚úÖ Found at: build/${pkg}/coverage.lcov"
            elif [ -f "${pkg}/coverage.lcov" ]; then
              PY_LCOV_FILE="${pkg}/coverage.lcov"
              echo "‚úÖ Found at: ${pkg}/coverage.lcov"
            fi
            
            if [ -n "$PY_LCOV_FILE" ]; then
              PKG_LINES_HIT=$(grep -E "^LH:" "$PY_LCOV_FILE" | cut -d: -f2 | awk '{s+=$1} END {print s}')
              PKG_LINES_FOUND=$(grep -E "^LF:" "$PY_LCOV_FILE" | cut -d: -f2 | awk '{s+=$1} END {print s}')
              PY_TOTAL_LINES_HIT=$((PY_TOTAL_LINES_HIT + PKG_LINES_HIT))
              PY_TOTAL_LINES_FOUND=$((PY_TOTAL_LINES_FOUND + PKG_LINES_FOUND))
              echo "üìä ${pkg}: LH=$PKG_LINES_HIT, LF=$PKG_LINES_FOUND"
            fi
          done
          
          if [ "$PY_TOTAL_LINES_FOUND" -gt 0 ]; then
            PY_COV_PCT=$(awk "BEGIN {printf \"%.0f\", ($PY_TOTAL_LINES_HIT/$PY_TOTAL_LINES_FOUND)*100}")
            echo "‚úÖ Total Python Coverage: $PY_COV_PCT%"
          else
            echo "‚ö†Ô∏è No Python coverage data found"
            PY_COV_PCT=0
          fi
          
          # Determine badge color
          if [ $PY_COV_PCT -ge 80 ]; then
            COLOR="brightgreen"
          elif [ $PY_COV_PCT -ge 60 ]; then
            COLOR="yellow"
          elif [ $PY_COV_PCT -ge 40 ]; then
            COLOR="orange"
          else
            COLOR="red"
          fi
          
          # Create badge JSON
          echo "{\"schemaVersion\": 1, \"label\": \"coverage\", \"message\": \"${PY_COV_PCT}%\", \"color\": \"$COLOR\"}" > coverage-badge.json
          cat coverage-badge.json

      - name: Upload coverage badge data
        if: always() && github.ref == 'refs/heads/jazzy-devel'
        continue-on-error: true
        uses: actions/upload-artifact@v4
        with:
          name: coverage-badge
          path: coverage-badge.json
          if-no-files-found: warn
      
      # Publish badges to badges branch for shields.io endpoint
      - name: Publish badges to badges branch
        if: always() && github.ref == 'refs/heads/jazzy-devel'
        run: |
          # Determine branch name for badge directory
          if [ "${{ github.ref }}" == "refs/heads/main" ]; then
            BRANCH_NAME="main"
          else
            BRANCH_NAME="jazzy-devel"
          fi
          
          # Setup git
          git config --global user.name "github-actions[bot]"
          git config --global user.email "github-actions[bot]@users.noreply.github.com"
          
          # Fetch and checkout badges branch (create if doesn't exist)
          echo "üîç Fetching badges branch..."
          git fetch origin badges || echo "‚ö†Ô∏è No remote badges branch found, will create new one"
          
          if git checkout badges; then
            echo "‚úÖ Checked out existing badges branch"
            # Pull latest to avoid conflicts
            git pull origin badges || true
          else
            echo "üìù Creating new orphan badges branch"
            git checkout --orphan badges
          fi
          
          # Create directory structure (don't remove existing files!)
          mkdir -p ${BRANCH_NAME}
          
          # Copy badge files to branch directory
          if [ -f "${{ github.workspace }}/test-badge.json" ]; then
            cp ${{ github.workspace }}/test-badge.json ${BRANCH_NAME}/
            echo "‚úÖ Copied test badge to ${BRANCH_NAME}/"
          fi
          
          if [ -f "${{ github.workspace }}/coverage-badge.json" ]; then
            cp ${{ github.workspace }}/coverage-badge.json ${BRANCH_NAME}/
            echo "‚úÖ Copied coverage badge to ${BRANCH_NAME}/"
          fi
          
          # Add, commit and push
          git add ${BRANCH_NAME}/
          
          if git diff --staged --quiet; then
            echo "‚ö†Ô∏è No changes to commit"
          else
            echo "üìù Committing badge updates..."
            git commit -m "Update badges for ${BRANCH_NAME} [skip ci]"
            
            echo "üöÄ Pushing to badges branch..."
            if git push origin badges; then
              echo "‚úÖ Successfully pushed badges to origin/badges"
            else
              echo "‚ö†Ô∏è First push failed, trying with --set-upstream..."
              git push --set-upstream origin badges
              echo "‚úÖ Successfully pushed badges with --set-upstream"
            fi
          fi

      - name: Log in to Docker Hub
        uses: docker/login-action@v3
        with:
          username: ${{ secrets.DOCKERHUB_USERNAME }}
          password: ${{ secrets.DOCKERHUB_TOKEN }}

      - name: Tag image for Docker Hub
        if: github.ref == 'refs/heads/main'
        run: |
          # Get the image name from .env file
          source Docker/.env
          DOCKERHUB_ORG=${{ secrets.DOCKERHUB_ORG }}
          
          # Tag the local image with Docker Hub organization name
          docker tag ${BUILT_IMAGE} ${DOCKERHUB_ORG}/eut_hri_faces:${TARGET_DISTRO}
      
      - name: Push to Docker Hub
        if: github.ref == 'none' # IGNORE for now the push, replace it with main when ready to publish from protected branch
        run: |
          source Docker/.env
          DOCKERHUB_ORG=${{ secrets.DOCKERHUB_ORG }}
          
          # Push the image to Docker Hub
          docker push ${DOCKERHUB_ORG}/eut_hri_faces:${TARGET_DISTRO}
