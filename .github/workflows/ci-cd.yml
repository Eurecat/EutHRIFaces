name: Build, Test & Push Docker Image

on:
  push:
    branches:
      - jazzy-devel
  pull_request:
    branches:
      - jazzy-devel
  workflow_dispatch:

jobs:
  build:
    runs-on: ubuntu-latest
    timeout-minutes: 45
    
    env:
      # Package Configuration - Define your ROS2 Python packages here
      PY_PACKAGES: "face_detection face_recognition gaze_estimation visual_speech_activity"
    
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
      
      # Clone EutRobAIDockers repository to build base image
      - name: Clone EutRobAIDockers repository
        run: |
          git clone https://github.com/Eurecat/EutRobAIDockers.git
          cd EutRobAIDockers
          echo "‚úÖ EutRobAIDockers repository cloned successfully"
      
      # Build the base image (eut_ros_torch_cpu:jazzy)
      - name: Build base image from EutRobAIDockers
        run: |
          cd EutRobAIDockers/Docker
          chmod +x build_container.sh
          ./build_container.sh --cpu --vulcanexus
        env:
          DOCKER_BUILDKIT: 1
      
      # Verify base image was built successfully
      - name: Verify base image was built
        run: |
          if docker images | grep -q "eut_ros_vulcanexus_torch_cpu.*jazzy"; then
            echo "‚úÖ Base image eut_ros_vulcanexus_torch_cpu:jazzy successfully built"
            docker images eut_ros_vulcanexus_torch_cpu:jazzy
          else
            echo "‚ùå Base image eut_ros_vulcanexus_torch_cpu:jazzy not found"
            echo "Available images:"
            docker images
            exit 1
          fi
      
      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3
      
      - name: Install vcstool for dependency management
        run: |
          sudo apt-get update
          sudo apt-get install -y python3-pip
          pip3 install --break-system-packages vcstool
      
      - name: Make build script executable
        run: chmod +x Docker/build_container.sh
      
      # Build the EutHRIFaces Docker image (depends on base image)
      - name: Build EutHRIFaces Docker image
        run: cd ./Docker && ./build_container.sh --cpu --vulcanexus
        env:
          DOCKER_BUILDKIT: 1
      
      - name: Verify EutHRIFaces image was built
        run: |
          if docker images | grep -q "eut_human_face_vulcanexus_cpu.*jazzy"; then
            echo "‚úÖ EutHRIFaces image eut_human_face_vulcanexus_cpu:jazzy successfully built"
            docker images eut_human_face_vulcanexus_cpu:jazzy
          else
            echo "‚ùå EutHRIFaces image eut_human_face_vulcanexus_cpu:jazzy not found"
            echo "Available images:"
            docker images
            exit 1
          fi
        
      # üîß Build workspace and run test
      - name: Build & test workspace
        run: |
          source Docker/.env
          
          # Build all packages with proper dependency order
          docker run --rm \
            -v ${{ github.workspace }}:/workspace \
            ${BUILT_IMAGE} \
            bash -c "
              # Source ROS environment (jazzy is available in both vulcanexus and standard images)
              if [ -f /opt/vulcanexus/jazzy/setup.bash ]; then
                source /opt/vulcanexus/jazzy/setup.bash
              elif [ -f /opt/ros/jazzy/setup.bash ]; then
                source /opt/ros/jazzy/setup.bash
              fi
              
              cd /workspace
              
              # Source the pre-built workspace dependencies from image (hri_msgs, etc.)
              if [ -f /opt/workspace/install/setup.bash ]; then
                source /opt/workspace/install/setup.bash
                echo '‚úÖ Sourced pre-built dependencies from image'
              fi
              
              echo 'üîç Available packages to build:'
              colcon list --names-only
              
              # Build Python packages
              echo 'üî® Building Python packages: ${{ env.PY_PACKAGES }}'
              
              colcon build --symlink-install \
                --packages-select ${{ env.PY_PACKAGES }} \
                --parallel-workers 1 \
                --event-handlers console_direct+ || echo 'Warning: Some Python packages failed to build'
              
              # Source the workspace to make built packages available
              source install/setup.bash
              
              # Set up test environment
              export PYTHONDONTWRITEBYTECODE=1
              export PYTHONHASHSEED=0
              export AI_VENV='/opt/ros_python_env'
              
              # Run tests for Python packages (one at a time to reduce memory)
              echo 'üß™ Running tests...'
              PY_PACKAGES_LIST='${{ env.PY_PACKAGES }}'
              
              for pkg in \${PY_PACKAGES_LIST}; do
                echo \"\n========================================\"
                echo \"Testing package: \$pkg\"
                echo \"========================================\"
                
                # Run tests with pytest and ensure coverage is generated
                cd /workspace/src/\$pkg
                python3 -m pytest test/ \
                  -v \
                  --tb=short \
                  --junitxml=/workspace/build/\$pkg/pytest.xml \
                  --cov=\$pkg \
                  --cov-report=html:/workspace/build/\$pkg/htmlcov \
                  --cov-report=lcov:/workspace/build/\$pkg/coverage.lcov \
                  --cov-report=xml:/workspace/build/\$pkg/coverage.xml \
                  --cov-report=term \
                  -p no:cacheprovider || echo \"‚ö†Ô∏è Some tests failed for \$pkg\"
                
                cd /workspace
                # Brief pause between packages
                sleep 1
              done
            "

      # Generate human-readable test summary
      - name: Generate test summary
        if: always()
        run: |
          source Docker/.env
          docker run --rm \
            -v ${{ github.workspace }}:/workspace \
            ${BUILT_IMAGE} \
            bash -c "
              cd /workspace
              if [ -f /opt/vulcanexus/jazzy/setup.bash ]; then
                source /opt/vulcanexus/jazzy/setup.bash
              elif [ -f /opt/ros/jazzy/setup.bash ]; then
                source /opt/ros/jazzy/setup.bash
              fi
              source install/setup.bash 2>/dev/null || true
              colcon test-result --all --verbose
            " > test_summary.txt
          
          # Display in logs
          cat test_summary.txt
          
          # Create GitHub Actions summary
          echo "## üß™ Test Results Summary" >> $GITHUB_STEP_SUMMARY
          echo '```' >> $GITHUB_STEP_SUMMARY
          cat test_summary.txt >> $GITHUB_STEP_SUMMARY
          echo '```' >> $GITHUB_STEP_SUMMARY
      
      - name: Generate test Report
        uses: dorny/test-reporter@v1
        if: always()
        with:
          name: ROS 2 Tests
          path: 'build/*/test_results/**/*.xml,build/*/pytest.xml'
          reporter: java-junit
          fail-on-error: false
      
      # Upload test result
      - name: Upload test results
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: test-results
          path: |
            build/*/test_results/**/*.xml
            build/*/pytest.xml
            log/latest_test/**/*.log
            test_summary.txt      
      # Verify coverage files were generated
      - name: Verify coverage files
        if: always()
        run: |
          echo "üìã Coverage files generated:"
          echo ""
          find build -type f \( -name "coverage.*" -o -name ".coverage" \) 2>/dev/null | while read f; do
            echo "‚úÖ $f ($(du -h "$f" | cut -f1))"
          done
          echo ""
          echo "üìã Test result files:"
          find build -name "pytest.xml" -type f 2>/dev/null | while read f; do
            echo "‚úÖ $f"
          done      
      # Create test badge (for README)
      - name: Create test badge
        if: always() && github.ref == 'refs/heads/main'
        run: |
          # Parse the summary line from test_summary.txt
          # Example line: "Summary: 55 tests, 0 errors, 0 failures, 6 skipped"
          if [ -f test_summary.txt ]; then
            SUMMARY_LINE=$(grep "^Summary:" test_summary.txt)
            
            # Extract numbers using grep and cut
            TOTAL=$(echo "$SUMMARY_LINE" | grep -oP '\d+(?= tests)' || echo "0")
            FAILURES=$(echo "$SUMMARY_LINE" | grep -oP '\d+(?= failures)' || echo "0")
            ERRORS=$(echo "$SUMMARY_LINE" | grep -oP '\d+(?= errors)' || echo "0")
            
            # Calculate passed tests (total - failures - errors)
            PASSED=$((TOTAL - FAILURES - ERRORS))
            FAILED=$((FAILURES + ERRORS))
            
            echo "üìä Badge stats: $PASSED passed / $FAILED failed (out of $TOTAL total)"
          else
            echo "‚ö†Ô∏è test_summary.txt not found, using defaults"
            PASSED=0
            FAILED=0
          fi
          
          # Create badge JSON (shields.io endpoint format)
          COLOR="success"
          if [ $FAILED -gt 0 ]; then
            COLOR="critical"
          fi
          
          echo "{\"schemaVersion\": 1, \"label\": \"tests\", \"message\": \"$PASSED passed / $FAILED failed\", \"color\": \"$COLOR\"}" > test-badge.json
          
          cat test-badge.json

      - name: Upload badge data
        if: always() && github.ref == 'refs/heads/main'
        uses: actions/upload-artifact@v4
        with:
          name: test-badge
          path: test-badge.json
      

      # Generate code coverage reports (from existing test data)
      - name: Generate coverage reports
        if: always()
        run: |
          source Docker/.env
          
          echo '=========================================='
          echo '  Code Coverage Summary Display'
          echo '=========================================='
          echo ''
          
          # Display Python coverage from existing files
          for pkg in ${{ env.PY_PACKAGES }}; do
            echo "üìä Python Coverage (${pkg})"
            echo '------------------------------------------'
            
            # Check for lcov file
            if [ -f "build/${pkg}/coverage.lcov" ]; then
              echo "‚úÖ Coverage data found in build/${pkg}/coverage.lcov"
              # Extract summary from lcov
              grep "^LH:\|^LF:" "build/${pkg}/coverage.lcov" | head -5 || true
            elif [ -f "build/${pkg}/coverage.xml" ]; then
              echo "‚úÖ Coverage data found in build/${pkg}/coverage.xml"
            else
              echo "‚ö†Ô∏è  No coverage data found for this package"
            fi
            echo ''
          done
          
          echo '=========================================='
          echo '‚úÖ Coverage Reports Generated!'
          echo '=========================================='
          
          # Summary of files found
          echo ""
          echo "Coverage files summary:"
          find build -name "coverage.*" -type f 2>/dev/null | wc -l
          echo "coverage files found"
      
      # Convert lcov to Cobertura XML for better tool compatibility
      - name: Convert coverage to Cobertura XML
        if: always()
        run: |
          python3 -m pip install lcov_cobertura
          
          echo "üìã Looking for coverage files..."
          find build -name "coverage.lcov" -o -name "coverage.xml" | head -20
          
          # Convert Python coverage lcov files to XML
          for pkg in ${{ env.PY_PACKAGES }}; do
            LCOV_FILE="build/${pkg}/coverage.lcov"
            if [ -f "$LCOV_FILE" ]; then
              echo "‚úÖ Converting Python coverage for ${pkg}..."
              python3 -m lcov_cobertura "$LCOV_FILE" -o "coverage-py-${pkg}.xml"
              echo "‚úÖ Generated: coverage-py-${pkg}.xml"
            else
              echo "‚ö†Ô∏è coverage.lcov not found for ${pkg} at $LCOV_FILE"
            fi
          done
          
          # Also copy any existing coverage.xml files
          for pkg in ${{ env.PY_PACKAGES }}; do
            if [ -f "build/${pkg}/coverage.xml" ]; then
              cp "build/${pkg}/coverage.xml" "coverage-py-${pkg}-direct.xml"
              echo "‚úÖ Copied coverage.xml for ${pkg}"
            fi
          done
          
          # List all generated coverage files
          echo ""
          echo "üìã Coverage files found:"
          ls -lh coverage-*.xml 2>/dev/null || echo "‚ö†Ô∏è No coverage XML files generated"
          echo ""
          find build -name "coverage.*" -type f 2>/dev/null | head -20
      
      # Generate Coverage Report for PR (using Cobertura XML)
      - name: Code Coverage Report
        uses: irongut/CodeCoverageSummary@v1.3.0
        if: always()
        continue-on-error: true
        with:
          filename: 'coverage-*.xml'
          badge: true
          fail_below_min: false
          format: markdown
          hide_branch_rate: false
          hide_complexity: true
          indicators: true
          output: both
          thresholds: '60 80'
      
      # Add coverage report to PR comment
      - name: Add Coverage PR Comment
        uses: marocchino/sticky-pull-request-comment@v2
        if: github.event_name == 'pull_request'
        continue-on-error: true
        with:
          recreate: true
          path: code-coverage-results.md
      
      # Upload coverage reports as artifacts
      - name: Upload coverage reports
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: coverage-reports
          path: |
            build/*/htmlcov/**
            build/*/coverage.*
            coverage_summary.txt
            coverage-*.xml
            code-coverage-results.md
      
      # Create coverage badge (for README)
      - name: Create coverage badge
        if: always() && github.ref == 'refs/heads/main'
        continue-on-error: true
        run: |
          echo "üîç Searching for Python coverage files..."
          find build -name "coverage.lcov" -o -name "coverage.xml" 2>/dev/null | head -20
          
          # Extract Python coverage for all packages
          PY_TOTAL_LINES_HIT=0
          PY_TOTAL_LINES_FOUND=0
          PACKAGES_WITH_COVERAGE=0
          
          for pkg in ${{ env.PY_PACKAGES }}; do
            echo "üîç Checking Python coverage for: ${pkg}"
            
            # Check lcov file first
            if [ -f "build/${pkg}/coverage.lcov" ]; then
              echo "‚úÖ Found LCOV: build/${pkg}/coverage.lcov"
              PKG_LINES_HIT=$(grep "^LH:" "build/${pkg}/coverage.lcov" | cut -d: -f2 | awk '{s+=$1} END {print s+0}')
              PKG_LINES_FOUND=$(grep "^LF:" "build/${pkg}/coverage.lcov" | cut -d: -f2 | awk '{s+=$1} END {print s+0}')
              
              if [ "$PKG_LINES_FOUND" -gt 0 ]; then
                PY_TOTAL_LINES_HIT=$((PY_TOTAL_LINES_HIT + PKG_LINES_HIT))
                PY_TOTAL_LINES_FOUND=$((PY_TOTAL_LINES_FOUND + PKG_LINES_FOUND))
                PACKAGES_WITH_COVERAGE=$((PACKAGES_WITH_COVERAGE + 1))
                echo "üìä ${pkg}: LH=$PKG_LINES_HIT, LF=$PKG_LINES_FOUND"
              fi
            elif [ -f "build/${pkg}/coverage.xml" ]; then
              echo "‚úÖ Found XML: build/${pkg}/coverage.xml"
              PACKAGES_WITH_COVERAGE=$((PACKAGES_WITH_COVERAGE + 1))
            fi
          done
          
          # Calculate coverage percentage
          if [ "$PY_TOTAL_LINES_FOUND" -gt 0 ]; then
            PY_COV_PCT=$(awk "BEGIN {printf \"%.0f\", (\$1/\$2)*100}" <<< "$PY_TOTAL_LINES_HIT $PY_TOTAL_LINES_FOUND")
            echo "‚úÖ Total Python Coverage: ${PY_COV_PCT}%"
          else
            echo "‚ö†Ô∏è No Python coverage metrics extracted (but ${PACKAGES_WITH_COVERAGE} packages have coverage files)"
            PY_COV_PCT=0
          fi
          
          # Determine badge color based on coverage
          if [ $PY_COV_PCT -ge 80 ]; then
            COLOR="brightgreen"
          elif [ $PY_COV_PCT -ge 60 ]; then
            COLOR="yellow"
          elif [ $PY_COV_PCT -ge 40 ]; then
            COLOR="orange"
          elif [ $PACKAGES_WITH_COVERAGE -gt 0 ]; then
            COLOR="blue"
            echo "‚ÑπÔ∏è Coverage detected but percentage could not be calculated"
          else
            COLOR="red"
          fi
          
          # Create badge JSON
          echo "{\"schemaVersion\": 1, \"label\": \"coverage\", \"message\": \"${PY_COV_PCT}%\", \"color\": \"$COLOR\"}" > coverage-badge.json
          cat coverage-badge.json

      - name: Upload coverage badge data
        if: always() && github.ref == 'refs/heads/main'
        uses: actions/upload-artifact@v4
        with:
          name: coverage-badge
          path: coverage-badge.json
      
      # Publish badges to badges branch for shields.io endpoint
      - name: Publish badges to badges branch
        if: always() && github.ref == 'refs/heads/main'
        run: |
          # Determine branch name for badge directory
          BRANCH_NAME="main"
          
          # Setup git
          git config --global user.name "github-actions[bot]"
          git config --global user.email "github-actions[bot]@users.noreply.github.com"
          
          # Fetch and checkout badges branch (create if doesn't exist)
          git fetch origin badges 2>/dev/null || true
          git checkout badges 2>/dev/null || git checkout --orphan badges
          
          # Clean working directory and create structure
          git rm -rf . 2>/dev/null || true
          mkdir -p ${BRANCH_NAME}
          
          # Copy badge files
          cp ${{ github.workspace }}/test-badge.json ${BRANCH_NAME}/ 2>/dev/null || echo "No test badge"
          cp ${{ github.workspace }}/coverage-badge.json ${BRANCH_NAME}/ 2>/dev/null || echo "No coverage badge"
          
          # Add, commit and push
          git add ${BRANCH_NAME}/
          git diff --staged --quiet || git commit -m "Update badges for ${BRANCH_NAME} [skip ci]"
          git push origin badges 2>/dev/null || git push --set-upstream origin badges

      - name: Log in to Docker Hub
        uses: docker/login-action@v3
        with:
          username: ${{ secrets.DOCKERHUB_USERNAME }}
          password: ${{ secrets.DOCKERHUB_TOKEN }}

      - name: Tag image for Docker Hub
        if: github.ref == 'refs/heads/main'
        run: |
          # Get the image name from .env file
          source Docker/.env
          DOCKERHUB_ORG=${{ secrets.DOCKERHUB_ORG }}
          
          # Tag the local image with Docker Hub organization name
          docker tag ${BUILT_IMAGE} ${DOCKERHUB_ORG}/eut_hri_faces:${TARGET_DISTRO}
      
      - name: Push to Docker Hub
        if: github.ref == 'none' # IGNORE for now the push, replace it with main when ready to publish from protected branch
        run: |
          source Docker/.env
          DOCKERHUB_ORG=${{ secrets.DOCKERHUB_ORG }}
          
          # Push the image to Docker Hub
          docker push ${DOCKERHUB_ORG}/eut_hri_faces:${TARGET_DISTRO}
